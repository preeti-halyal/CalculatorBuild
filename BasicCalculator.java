package com.cts.sonarhandson;

public class BasicCalculator 
{
	public int add(int a,int b)
	{
		int c;
		c = a+b;
		System.out.println("Adding 2 numbers: "+c);
		return c;
		
	}
	
	// Generated by Copilot- Start
	public int addThreeNumbers(int a, int b, int c)
	{
		int result;
		result = a + b + c;
		System.out.println("Adding 3 numbers: " + result);
		return result;
	}
	// Generated by Copilot- End
	
	public int sub(int a,int b)
	{
		int c;
		c = a-b;
		System.out.println("Substracting 2 numbers: "+c);
		return c;
	}
	
	public int divide(int a, int b) throws Exception
	{
		if (b==0)
		{
			throw new Exception("Denominator cannot be 0.");
		}
		return a/b;
	}
	
	public boolean equalIntegers(int a,int b)
	{
		boolean result = false;
		if(a==b)
		{
			result = true;
		}
		return result;
	}

// Generated by Copilot- Start
	//add a method to verify if a number is even or odd
	public boolean isEven(int a)
	{
		boolean result = false;
		if(a%2==0)
		{
			result = true;
		}
		return result;
	}
	// Generated by Copilot- End
	// Generated by Copilot- Start
//add a method to verify if a number is prime or not
	public boolean isPrime(int number) {
	    if (number <= 1) {
	        return false;
	    }
	    for (int i = 2; i <= Math.sqrt(number); i++) {
	        if (number % i == 0) {
	            return false;
	        }
	    }
	    return true;
	}
	// Generated by Copilot- End
	// Generated by Copilot- Start
	//add a method to verify if a number is composite or not
	public boolean isComposite(int number) {
	    if (number <= 1) {
	        return false;
	    }
	    for (int i = 2; i <= Math.sqrt(number); i++) {
	        if (number % i == 0) {
	            return true;
	        }
	    }
	    return false;
	}
	// Generated by Copilot- End
	// Generated by Copilot- Start
	//add a method to calculate the factorial of a number
	public int factorial(int number) {
	    if (number < 0) {
	        throw new IllegalArgumentException("Number must be non-negative.");
	    }
	    int result = 1;
	    for (int i = 1; i <= number; i++) {
	        result *= i;
	    }
	    return result;
	}
	// Generated by Copilot- End
	// Generated by Copilot- Start
	//add a method to calculate the power of a number
	public double power(double base, int exponent) {
			    return Math.pow(base, exponent);
	}
	// Generated by Copilot- End

		// Generated by Copilot- Start
	public int multiplyThreeNumbers(int a, int b, int c)
	{
		int result;
		result = a * b * c;
		System.out.println("Multiplying 3 numbers: " + result);
		return result;
	}
	// Generated by Copilot- End

	// Generated by Copilot- Start
	public double squareRoot(double number) throws IllegalArgumentException
	{
		if (number < 0) {
			throw new IllegalArgumentException("Cannot calculate square root of negative number.");
		}
		double result = Math.sqrt(number);
		System.out.println("Square root of " + number + ": " + result);
		return result;
	}
	// Generated by Copilot- End

		// Generated by Copilot- Start
	public double calculatePercentage(double value, double percentage)
	{
		double result = (value * percentage) / 100;
		System.out.println(percentage + "% of " + value + ": " + result);
		return result;
	}
	// Generated by Copilot- End

	// Generated by Copilot- Start
	public double scientificCalculator(String operation, double operand1, double operand2) throws IllegalArgumentException
	{
		double result = 0.0;
		String formattedOperation = operation.toLowerCase().trim();
		
		System.out.println("Scientific Calculator - Operation: " + operation);
		System.out.println("Operand 1: " + operand1 + ", Operand 2: " + operand2);
		
		switch (formattedOperation) {
			case "sin":
				result = Math.sin(Math.toRadians(operand1));
				System.out.println("Sine of " + operand1 + " degrees: " + result);
				break;
				
			case "cos":
				result = Math.cos(Math.toRadians(operand1));
				System.out.println("Cosine of " + operand1 + " degrees: " + result);
				break;
				
			case "tan":
				result = Math.tan(Math.toRadians(operand1));
				System.out.println("Tangent of " + operand1 + " degrees: " + result);
				break;
				
			case "log":
				if (operand1 <= 0) {
					throw new IllegalArgumentException("Logarithm requires positive numbers.");
				}
				result = Math.log10(operand1);
				System.out.println("Log base 10 of " + operand1 + ": " + result);
				break;
				
			case "ln":
				if (operand1 <= 0) {
					throw new IllegalArgumentException("Natural logarithm requires positive numbers.");
				}
				result = Math.log(operand1);
				System.out.println("Natural logarithm of " + operand1 + ": " + result);
				break;
				
			case "pow":
				result = Math.pow(operand1, operand2);
				System.out.println(operand1 + " raised to power " + operand2 + ": " + result);
				break;
				
			case "sqrt":
				if (operand1 < 0) {
					throw new IllegalArgumentException("Square root requires non-negative numbers.");
				}
				result = Math.sqrt(operand1);
				System.out.println("Square root of " + operand1 + ": " + result);
				break;
				
			case "cbrt":
				result = Math.cbrt(operand1);
				System.out.println("Cube root of " + operand1 + ": " + result);
				break;
				
			case "abs":
				result = Math.abs(operand1);
				System.out.println("Absolute value of " + operand1 + ": " + result);
				break;
				
			case "ceil":
				result = Math.ceil(operand1);
				System.out.println("Ceiling of " + operand1 + ": " + result);
				break;
				
			case "floor":
				result = Math.floor(operand1);
				System.out.println("Floor of " + operand1 + ": " + result);
				break;
				
			case "round":
				result = Math.round(operand1);
				System.out.println("Rounded value of " + operand1 + ": " + result);
				break;
				
			case "max":
				result = Math.max(operand1, operand2);
				System.out.println("Maximum of " + operand1 + " and " + operand2 + ": " + result);
				break;
				
			case "min":
				result = Math.min(operand1, operand2);
				System.out.println("Minimum of " + operand1 + " and " + operand2 + ": " + result);
				break;
				
			case "hypot":
				result = Math.hypot(operand1, operand2);
				System.out.println("Hypotenuse of " + operand1 + " and " + operand2 + ": " + result);
				break;
				
			case "atan2":
				result = Math.toDegrees(Math.atan2(operand1, operand2));
				System.out.println("Arctangent2 of (" + operand1 + ", " + operand2 + "): " + result + " degrees");
				break;
				
			case "random":
				result = Math.random() * operand1;
				System.out.println("Random number between 0 and " + operand1 + ": " + result);
				break;
				
			case "factorial":
				if (operand1 < 0 || operand1 != Math.floor(operand1)) {
					throw new IllegalArgumentException("Factorial requires non-negative integers.");
				}
				result = calculateFactorialHelper((int)operand1);
				System.out.println("Factorial of " + (int)operand1 + ": " + result);
				break;
				
			case "combination":
				if (operand1 < 0 || operand2 < 0 || operand1 != Math.floor(operand1) || operand2 != Math.floor(operand2)) {
					throw new IllegalArgumentException("Combination requires non-negative integers.");
				}
				if (operand2 > operand1) {
					throw new IllegalArgumentException("In combination, second operand cannot be greater than first.");
				}
				result = calculateFactorialHelper((int)operand1) / 
						(calculateFactorialHelper((int)operand2) * calculateFactorialHelper((int)(operand1 - operand2)));
				System.out.println("Combination C(" + (int)operand1 + ", " + (int)operand2 + "): " + result);
				break;
				
			case "permutation":
				if (operand1 < 0 || operand2 < 0 || operand1 != Math.floor(operand1) || operand2 != Math.floor(operand2)) {
					throw new IllegalArgumentException("Permutation requires non-negative integers.");
				}
				if (operand2 > operand1) {
					throw new IllegalArgumentException("In permutation, second operand cannot be greater than first.");
				}
				result = calculateFactorialHelper((int)operand1) / calculateFactorialHelper((int)(operand1 - operand2));
				System.out.println("Permutation P(" + (int)operand1 + ", " + (int)operand2 + "): " + result);
				break;
				
			case "gcd":
				if (operand1 != Math.floor(operand1) || operand2 != Math.floor(operand2)) {
					throw new IllegalArgumentException("GCD requires integers.");
				}
				result = calculateGCD((int)Math.abs(operand1), (int)Math.abs(operand2));
				System.out.println("Greatest Common Divisor of " + (int)operand1 + " and " + (int)operand2 + ": " + result);
				break;
				
			case "lcm":
				if (operand1 != Math.floor(operand1) || operand2 != Math.floor(operand2)) {
					throw new IllegalArgumentException("LCM requires integers.");
				}
				int gcdValue = calculateGCD((int)Math.abs(operand1), (int)Math.abs(operand2));
				result = Math.abs(operand1 * operand2) / gcdValue;
				System.out.println("Least Common Multiple of " + (int)operand1 + " and " + (int)operand2 + ": " + result);
				break;
				
			default:
				throw new IllegalArgumentException("Unknown operation: " + operation + 
					". Supported operations: sin, cos, tan, log, ln, pow, sqrt, cbrt, abs, ceil, floor, round, max, min, hypot, atan2, random, factorial, combination, permutation, gcd, lcm");
		}
		
		System.out.println("Final result: " + result);
		return result;
	}
	
	private double calculateFactorialHelper(int n) 
	{
		if (n <= 1) return 1;
		double factorial = 1;
		for (int i = 2; i <= n; i++) {
			factorial *= i;
		}
		return factorial;
	}
	
	private int calculateGCD(int a, int b) 
	{
		while (b != 0) {
			int temp = b;
			b = a % b;
			a = temp;
		}
		return a;
	}
	// Generated by Copilot- End

	// Generated by Copilot comments blocks lines added count: 238
}




